# runBlocking：从外部看 & 从内部看（上下文梳理）

## 从 `runBlocking` 外部看（调用者视角：线程 + 顺序）

假设 **A 线程**调用：

```kotlin
runBlocking {
  // ...
}
```

### 1）阻塞（blocking）语义：后续代码一定等它结束
- `runBlocking { ... }` 是一个**普通函数调用**，语义是：把 block 内的协程体跑完，并**同步返回结果/抛出异常**。
- 因此它会**阻塞调用它的当前线程（A 线程）**：
  - A 线程会停在 `runBlocking` 这一行；
  - 直到 block **执行完成**（并且它作用域内的子协程也完成）后，`runBlocking` 才返回；
  - **`runBlocking` 后面的代码必然在 `runBlocking` 返回之后才执行。**

### 2）block 内“非挂起代码”默认在哪个线程执行
- 在**没有显式切换协程上下文/调度器**的前提下：
  - `runBlocking { ... }` 内部那些**普通 Kotlin 语句 / 非 suspend 调用**，默认就在**调用 `runBlocking` 的线程（A 线程）**执行。
- 直观理解：`runBlocking` 占住了 A 线程，并在这条线程上推动协程体向前执行。

### 3）外部看：哪些情况会让 block 内部出现“局部不在 A 线程跑”
即便 A 线程被 `runBlocking` 阻塞，block 内部仍可能有部分工作发生在其他线程，这通常来自两类原因：

- **显式切换调度器**
  - `withContext(Dispatchers.IO) { ... }`
  - `launch(Dispatchers.Default) { ... }`
  - 这些代码块会在对应调度器（线程池）上运行。
- **库内部线程池工作**
  - 例如 Retrofit/OkHttp：网络 I/O 由 OkHttp 的 Dispatcher 线程池执行。
  - 但挂起点前后你写的“普通语句”，恢复后通常会回到 `runBlocking` 的上下文继续（常见就是 A 线程）。

> 一句话总结（外部）：`runBlocking` 把协程包装成同步调用——它会阻塞调用线程；且在不切换调度器时，block 内普通代码默认也在该线程执行。


---

## 从 `runBlocking` 内部看（协程体视角：顺序 + 挂起/恢复 + 子协程）

进入 `runBlocking { ... }` 后，可以把内部理解���“一个协程作用域里的顺序代码”。

### 1）顺序执行语义（看起来像同步代码）
- block 内代码从上到下执行，和普通函数体类似。

### 2）遇到 `suspend`：挂起等待，完成后继续
- 当执行到挂起函数（`suspend fun`）时：
  - 协程会**挂起**在该调用处（逻辑上的“暂停”）；
  - 等待结果就绪后再**恢复（resume）**；
  - 恢复后继续执行挂起调用后面的语句。
- 这就是“看起来像同步等待”的原因：写法是顺序的，但等待期间不等于必须占用同一个执行线程做 I/O。

### 3）内部默认在哪个线程继续执行（以及如何切换）
- 默认情况下（不切换 dispatcher）：
  - 协程挂起点恢复后继续执行的代码，通常仍在 `runBlocking` 的上下文线程上运行（常见就是调用它的 A 线程）。
- 如果在内部显式切换上下文：
  - `withContext(Dispatchers.IO)` 内部代码在 IO 线程池；
  - 结束后回到 `runBlocking` 的上下文继续执行（通常回 A 线程）。

### 4）结构化并发：`runBlocking` 会等待其作用域内的子协程完成
- 在 `runBlocking` 里启动的子协程（如 `launch { ... }`、`async { ... }`）默认是其子任务：
  - `runBlocking` 会等这些子协程都结束，才会返回到外部。
- 只有当你刻意使用脱离作用域的方式（例如 `GlobalScope.launch { ... }` 或自行创建独立 scope）才可能出现“runBlocking 返回了但后台仍在跑”的情况。

> 一句话总结（内部）：内部代码顺序执行；遇到挂起点就挂起等待，完成后恢复继续；默认在 `runBlocking` 的上下文线程继续执行，但可通过调度器切换部分工作到其他线程；并且会等待其作用域内子协程完成。


---

## 串起来的整体时间线（外部 + 内部）

1. A 线程调用 `runBlocking { ... }`  
2. A 线程进入阻塞等待状态（停在 `runBlocking` 这一行，直到整体完成）  
3. `runBlocking` 内部协程体开始在 A 线程执行普通语句  
4. 遇到 `suspend` 挂起点：协程挂起等待结果  
   - 可能由其他线程池完成实际工作（例如 OkHttp 线程池）  
5. 结果就绪：协程恢复（通常回到 A 线程继续）  
6. block（以及其子协程）全部完成：`runBlocking` 返回  
7. A 线程继续执行 `runBlocking` 后面的代码