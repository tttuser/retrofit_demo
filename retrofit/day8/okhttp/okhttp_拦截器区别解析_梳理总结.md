# OkHttp 拦截器区别解析（梳理总结）

> 基于附件内容（对话导出）整理：围绕 `addInterceptor`（应用拦截器）与 `addNetworkInterceptor`（网络拦截器）的区别、执行顺序/时机、`proceed()` 的意义、缓存与责任链/装饰模式关系等。

---

## 1. 两类拦截器的本质区别

OkHttp 中：

- `addInterceptor(...)` 添加的是 **应用拦截器（Application Interceptor）**
- `addNetworkInterceptor(...)` 添加的是 **网络拦截器（Network Interceptor）**

两者差异来自它们在 OkHttp **拦截器责任链中的位置不同**，因此能“看到”的请求/响应范围也不同��

---

## 2. 核心对比（位置、频率、缓存、可见信息）

| 维度 | 应用拦截器 `addInterceptor` | 网络拦截器 `addNetworkInterceptor` |
|---|---|---|
| 责任链位置 | **更靠外/更上层**：应用代码与 OkHttp Core 之间 | **更靠内/更下层**：OkHttp Core 与真实网络 I/O 之间 |
| 执行次数 | 通常 **一次 call 只触发一次**（不关心内部重试/重定向细节） | **一次 call 可能触发多次**（每次真实网络请求都会触发：重试/重定向都会增加次数） |
| 缓存命中 | **仍会执行**（因为即使命中缓存，对上层来说依然是一次“请求-响应”流程） | **不会执行**（如果命中缓存，没有真实网络传输，就不会到 network interceptors） |
| 能看到的请求形态 | 更接近“业务意图”的原始请求 | 更接近“最终发往网络”的请求（包含 OkHttp 自动补齐/转换后的信息） |
| 典型用途 | 统一加 Header/Token、签名、通用错误处理、应用层日志、Mock/短路 | 观察真实网络流量、调试重定向过程、需要连接层信息/网络细节的场景 |

---

## 3. “老板 vs 快递员”类比（理解视角）

- **应用拦截器**像“老板”：只关心“我下单 -> 我拿到结果”，不关心中间跑了几次。
- **网络拦截器**像“快递员”：每次真正出门送货/取货（真实网络 I/O）都会被记录；如果中途改地址（重定向）就会跑多次；如果仓库直接取货（缓存命中）就根本不会出门。

一句话总结：

- `addInterceptor` 关注 **一次逻辑调用的开始/结束**
- `addNetworkInterceptor` 关注 **每一次真实网络传输的开始/结束**

---

## 4. 多个 `addInterceptor` 的执行顺序（洋葱模型 / 先进后出）

当添加多个应用拦截器时：

- **Request 去程**：按添加顺序执行（先 add 的先处理）
- **Response 回程**：按添加顺序反向执行（后 add 的先拿到响应）

示例（先 add A，再 add B）：

- Request：A -> B -> OkHttp 内部
- Response：OkHttp 内部 -> B -> A

这是一种典型的“洋葱模型/回形针结构”：拦截器在 `chain.proceed()` 前后分别处理 request/response。

---

## 5. 不调用 `chain.proceed()` 会怎样？（Short-Circuit/短路）

在 `Interceptor.intercept()` 中 **不调用 `chain.proceed(request)`** 等价于：

- **切断责任链**：后续拦截器不会执行
- **不会发起真实网络请求**
- 但 `intercept()` 必须返回 `Response`，因此需要 **自行构造并返回一个 Response**

这常用于���

- Mock 数据（后端未就绪）
- 离线模式（无网时本地返回）
- 主动屏蔽某些请求（节省流量/避免不必要请求）

---

## 6. 用拦截器做缓存 vs `OkHttpClient.cache(cache)`（是否类似）

附件内容指出：`OkHttpClient.Builder().cache(cache)` 配置的标准缓存，在 OkHttp 内部本质上由一个内置拦截器 **`CacheInterceptor`** 完成。

它的行为与“自定义拦截器缓存”在机制上相似（都是责任链中的一个节点，能选择短路/放行），但标准 Cache 的特点是：

- **严格遵守 HTTP 缓存规范**（例如 `Cache-Control`、`ETag/Last-Modified`、`304`、`Vary` 等）
- **并发与磁盘 LRU 管理更成熟**

自定义拦截器缓存则更灵活（可以忽略服务端缓存头、使用 DB 存储等），但要自己处理大量边界与协议细节。

---

## 7. OkHttp 拦截器链是不是责任链模式？与装饰模式像不像？

结论（按附件观点整理）：

- **宏观意图**：是典型的 **责任链模式（Chain of Responsibility）**
  - 多个节点按序处理请求
  - 通过 `proceed()` 把控制权交给下一个节点
  - 支持“短路”（不 proceed 直接返回）
- **实现结构/调用方式**：又很像 **装饰模式（Decorator）**
  - 层层包裹（每个拦截器在 `proceed()` 前后增强逻辑）
  - 递归/调用栈驱动（不是简单 for-loop）

可以理解为：**责任链的意图 + 装饰器式的实现形态（函数链/���截过滤器模式）**。

---

## 8. 为什么不强制要求必须调用 `proceed()`？

附件讨论认为：如果把 `proceed()` 设计成“模板方法强制调用”，会削弱甚至破坏 OkHttp 的核心能力，例如：

- 缓存需要“命中即短路”
- 重试需要“可多次 proceed”
- Mock/离线/权限校验等需要“可直接返回”

因此 OkHttp 选择提供“足够锋利”的底层机制；如果团队要防呆/管控，应在业务层封装（例如提供受限基类拦截器、统一工厂构建 OkHttpClient、Lint/Review 规则等）。

---

## 9. 实践建议（如何选择与排列）

- 默认优先用 `addInterceptor`：覆盖绝大多数业务需求（加 Token、日志、统一错误处理）
- 需要观察“真实网络层细节”时再用 `addNetworkInterceptor`
- 多拦截器顺序建议（经验性）：
  - 想打印最终形态请求：日志拦截器放得更靠内（更后 add）
  - 需要统一加参数/Header：通常放在较靠内（更后 add），确保对最终请求生效（并避免前面日志打印到未加工请求）

---